///
/// @file   proto_io.cpp
/// @Author Adam Saxen
/// @date   Oktober, 2016
/// @brief  Auto generated Wrapper class for NanoPb library
///
/// This class is autogenerated based on the proto file
///
#include "proto_io.h"

namespace ioant
{

    /// =======================================================================
    /// Message methods for class Configuration
    /// =======================================================================
    ConfigurationMessage::ConfigurationMessage(){
        data = Configuration_init_zero;
        messageMeta_.message_type = 0;
    }

    bool ConfigurationMessage::Encode(){
        if (send_buffer_ == NULL){
            Serial.print("Heap taken! ");
            Serial.println("Configuration");
            send_buffer_ = (uint8_t*)calloc(128, sizeof(uint8_t));
        }
        pb_ostream_t stream = pb_ostream_from_buffer(send_buffer_, 128);
        bool status = pb_encode(&stream, Configuration_fields, &data);
        messageMeta_.number_of_bytes = (uint8_t)stream.bytes_written;
        messageMeta_.valid = status;
        return status;
    }

    bool ConfigurationMessage::Decode(const uint8_t* buffer, unsigned int number_of_bytes){
        pb_istream_t stream = pb_istream_from_buffer(buffer, number_of_bytes);
        bool status = pb_decode(&stream, Configuration_fields, &data);
        messageMeta_.valid = status;
        messageMeta_.number_of_bytes = number_of_bytes;
        has_decoded_data_ = true;
        return status;
    }

    /// =======================================================================
    /// Message methods for class BootInfo
    /// =======================================================================
    BootInfoMessage::BootInfoMessage(){
        data = BootInfo_init_zero;
        messageMeta_.message_type = 1;
    }

    bool BootInfoMessage::Encode(){
        if (send_buffer_ == NULL){
            Serial.print("Heap taken! ");
            Serial.println("BootInfo");
            send_buffer_ = (uint8_t*)calloc(128, sizeof(uint8_t));
        }
        pb_ostream_t stream = pb_ostream_from_buffer(send_buffer_, 128);
        bool status = pb_encode(&stream, BootInfo_fields, &data);
        messageMeta_.number_of_bytes = (uint8_t)stream.bytes_written;
        messageMeta_.valid = status;
        return status;
    }

    bool BootInfoMessage::Decode(const uint8_t* buffer, unsigned int number_of_bytes){
        pb_istream_t stream = pb_istream_from_buffer(buffer, number_of_bytes);
        bool status = pb_decode(&stream, BootInfo_fields, &data);
        messageMeta_.valid = status;
        messageMeta_.number_of_bytes = number_of_bytes;
        has_decoded_data_ = true;
        return status;
    }

    /// =======================================================================
    /// Message methods for class Image
    /// =======================================================================
    ImageMessage::ImageMessage(){
        data = Image_init_zero;
        messageMeta_.message_type = 2;
    }

    bool ImageMessage::Encode(){
        if (send_buffer_ == NULL){
            Serial.print("Heap taken! ");
            Serial.println("Image");
            send_buffer_ = (uint8_t*)calloc(128, sizeof(uint8_t));
        }
        pb_ostream_t stream = pb_ostream_from_buffer(send_buffer_, 128);
        bool status = pb_encode(&stream, Image_fields, &data);
        messageMeta_.number_of_bytes = (uint8_t)stream.bytes_written;
        messageMeta_.valid = status;
        return status;
    }

    bool ImageMessage::Decode(const uint8_t* buffer, unsigned int number_of_bytes){
        pb_istream_t stream = pb_istream_from_buffer(buffer, number_of_bytes);
        bool status = pb_decode(&stream, Image_fields, &data);
        messageMeta_.valid = status;
        messageMeta_.number_of_bytes = number_of_bytes;
        has_decoded_data_ = true;
        return status;
    }

    /// =======================================================================
    /// Message methods for class Trigger
    /// =======================================================================
    TriggerMessage::TriggerMessage(){
        data = Trigger_init_zero;
        messageMeta_.message_type = 3;
    }

    bool TriggerMessage::Encode(){
        if (send_buffer_ == NULL){
            Serial.print("Heap taken! ");
            Serial.println("Trigger");
            send_buffer_ = (uint8_t*)calloc(128, sizeof(uint8_t));
        }
        pb_ostream_t stream = pb_ostream_from_buffer(send_buffer_, 128);
        bool status = pb_encode(&stream, Trigger_fields, &data);
        messageMeta_.number_of_bytes = (uint8_t)stream.bytes_written;
        messageMeta_.valid = status;
        return status;
    }

    bool TriggerMessage::Decode(const uint8_t* buffer, unsigned int number_of_bytes){
        pb_istream_t stream = pb_istream_from_buffer(buffer, number_of_bytes);
        bool status = pb_decode(&stream, Trigger_fields, &data);
        messageMeta_.valid = status;
        messageMeta_.number_of_bytes = number_of_bytes;
        has_decoded_data_ = true;
        return status;
    }

    /// =======================================================================
    /// Message methods for class Temperature
    /// =======================================================================
    TemperatureMessage::TemperatureMessage(){
        data = Temperature_init_zero;
        messageMeta_.message_type = 4;
    }

    bool TemperatureMessage::Encode(){
        if (send_buffer_ == NULL){
            Serial.print("Heap taken! ");
            Serial.println("Temperature");
            send_buffer_ = (uint8_t*)calloc(128, sizeof(uint8_t));
        }
        pb_ostream_t stream = pb_ostream_from_buffer(send_buffer_, 128);
        bool status = pb_encode(&stream, Temperature_fields, &data);
        messageMeta_.number_of_bytes = (uint8_t)stream.bytes_written;
        messageMeta_.valid = status;
        return status;
    }

    bool TemperatureMessage::Decode(const uint8_t* buffer, unsigned int number_of_bytes){
        pb_istream_t stream = pb_istream_from_buffer(buffer, number_of_bytes);
        bool status = pb_decode(&stream, Temperature_fields, &data);
        messageMeta_.valid = status;
        messageMeta_.number_of_bytes = number_of_bytes;
        has_decoded_data_ = true;
        return status;
    }

    /// =======================================================================
    /// Message methods for class Humidity
    /// =======================================================================
    HumidityMessage::HumidityMessage(){
        data = Humidity_init_zero;
        messageMeta_.message_type = 5;
    }

    bool HumidityMessage::Encode(){
        if (send_buffer_ == NULL){
            Serial.print("Heap taken! ");
            Serial.println("Humidity");
            send_buffer_ = (uint8_t*)calloc(128, sizeof(uint8_t));
        }
        pb_ostream_t stream = pb_ostream_from_buffer(send_buffer_, 128);
        bool status = pb_encode(&stream, Humidity_fields, &data);
        messageMeta_.number_of_bytes = (uint8_t)stream.bytes_written;
        messageMeta_.valid = status;
        return status;
    }

    bool HumidityMessage::Decode(const uint8_t* buffer, unsigned int number_of_bytes){
        pb_istream_t stream = pb_istream_from_buffer(buffer, number_of_bytes);
        bool status = pb_decode(&stream, Humidity_fields, &data);
        messageMeta_.valid = status;
        messageMeta_.number_of_bytes = number_of_bytes;
        has_decoded_data_ = true;
        return status;
    }

    /// =======================================================================
    /// Message methods for class Mass
    /// =======================================================================
    MassMessage::MassMessage(){
        data = Mass_init_zero;
        messageMeta_.message_type = 6;
    }

    bool MassMessage::Encode(){
        if (send_buffer_ == NULL){
            Serial.print("Heap taken! ");
            Serial.println("Mass");
            send_buffer_ = (uint8_t*)calloc(128, sizeof(uint8_t));
        }
        pb_ostream_t stream = pb_ostream_from_buffer(send_buffer_, 128);
        bool status = pb_encode(&stream, Mass_fields, &data);
        messageMeta_.number_of_bytes = (uint8_t)stream.bytes_written;
        messageMeta_.valid = status;
        return status;
    }

    bool MassMessage::Decode(const uint8_t* buffer, unsigned int number_of_bytes){
        pb_istream_t stream = pb_istream_from_buffer(buffer, number_of_bytes);
        bool status = pb_decode(&stream, Mass_fields, &data);
        messageMeta_.valid = status;
        messageMeta_.number_of_bytes = number_of_bytes;
        has_decoded_data_ = true;
        return status;
    }

    /// =======================================================================
    /// Message methods for class ElectricPower
    /// =======================================================================
    ElectricPowerMessage::ElectricPowerMessage(){
        data = ElectricPower_init_zero;
        messageMeta_.message_type = 7;
    }

    bool ElectricPowerMessage::Encode(){
        if (send_buffer_ == NULL){
            Serial.print("Heap taken! ");
            Serial.println("ElectricPower");
            send_buffer_ = (uint8_t*)calloc(128, sizeof(uint8_t));
        }
        pb_ostream_t stream = pb_ostream_from_buffer(send_buffer_, 128);
        bool status = pb_encode(&stream, ElectricPower_fields, &data);
        messageMeta_.number_of_bytes = (uint8_t)stream.bytes_written;
        messageMeta_.valid = status;
        return status;
    }

    bool ElectricPowerMessage::Decode(const uint8_t* buffer, unsigned int number_of_bytes){
        pb_istream_t stream = pb_istream_from_buffer(buffer, number_of_bytes);
        bool status = pb_decode(&stream, ElectricPower_fields, &data);
        messageMeta_.valid = status;
        messageMeta_.number_of_bytes = number_of_bytes;
        has_decoded_data_ = true;
        return status;
    }

    /// =======================================================================
    /// Message methods for class GpsCoordinates
    /// =======================================================================
    GpsCoordinatesMessage::GpsCoordinatesMessage(){
        data = GpsCoordinates_init_zero;
        messageMeta_.message_type = 8;
    }

    bool GpsCoordinatesMessage::Encode(){
        if (send_buffer_ == NULL){
            Serial.print("Heap taken! ");
            Serial.println("GpsCoordinates");
            send_buffer_ = (uint8_t*)calloc(128, sizeof(uint8_t));
        }
        pb_ostream_t stream = pb_ostream_from_buffer(send_buffer_, 128);
        bool status = pb_encode(&stream, GpsCoordinates_fields, &data);
        messageMeta_.number_of_bytes = (uint8_t)stream.bytes_written;
        messageMeta_.valid = status;
        return status;
    }

    bool GpsCoordinatesMessage::Decode(const uint8_t* buffer, unsigned int number_of_bytes){
        pb_istream_t stream = pb_istream_from_buffer(buffer, number_of_bytes);
        bool status = pb_decode(&stream, GpsCoordinates_fields, &data);
        messageMeta_.valid = status;
        messageMeta_.number_of_bytes = number_of_bytes;
        has_decoded_data_ = true;
        return status;
    }

    /// =======================================================================
    /// Message methods for class RunStepperMotorRaw
    /// =======================================================================
    RunStepperMotorRawMessage::RunStepperMotorRawMessage(){
        data = RunStepperMotorRaw_init_zero;
        messageMeta_.message_type = 9;
    }

    bool RunStepperMotorRawMessage::Encode(){
        if (send_buffer_ == NULL){
            Serial.print("Heap taken! ");
            Serial.println("RunStepperMotorRaw");
            send_buffer_ = (uint8_t*)calloc(128, sizeof(uint8_t));
        }
        pb_ostream_t stream = pb_ostream_from_buffer(send_buffer_, 128);
        bool status = pb_encode(&stream, RunStepperMotorRaw_fields, &data);
        messageMeta_.number_of_bytes = (uint8_t)stream.bytes_written;
        messageMeta_.valid = status;
        return status;
    }

    bool RunStepperMotorRawMessage::Decode(const uint8_t* buffer, unsigned int number_of_bytes){
        pb_istream_t stream = pb_istream_from_buffer(buffer, number_of_bytes);
        bool status = pb_decode(&stream, RunStepperMotorRaw_fields, &data);
        messageMeta_.valid = status;
        messageMeta_.number_of_bytes = number_of_bytes;
        has_decoded_data_ = true;
        return status;
    }

    /// =======================================================================
    /// Message methods for class RunStepperMotor
    /// =======================================================================
    RunStepperMotorMessage::RunStepperMotorMessage(){
        data = RunStepperMotor_init_zero;
        messageMeta_.message_type = 10;
    }

    bool RunStepperMotorMessage::Encode(){
        if (send_buffer_ == NULL){
            Serial.print("Heap taken! ");
            Serial.println("RunStepperMotor");
            send_buffer_ = (uint8_t*)calloc(128, sizeof(uint8_t));
        }
        pb_ostream_t stream = pb_ostream_from_buffer(send_buffer_, 128);
        bool status = pb_encode(&stream, RunStepperMotor_fields, &data);
        messageMeta_.number_of_bytes = (uint8_t)stream.bytes_written;
        messageMeta_.valid = status;
        return status;
    }

    bool RunStepperMotorMessage::Decode(const uint8_t* buffer, unsigned int number_of_bytes){
        pb_istream_t stream = pb_istream_from_buffer(buffer, number_of_bytes);
        bool status = pb_decode(&stream, RunStepperMotor_fields, &data);
        messageMeta_.valid = status;
        messageMeta_.number_of_bytes = number_of_bytes;
        has_decoded_data_ = true;
        return status;
    }

    /// =======================================================================
    /// Message methods for class RunDcMotor
    /// =======================================================================
    RunDcMotorMessage::RunDcMotorMessage(){
        data = RunDcMotor_init_zero;
        messageMeta_.message_type = 11;
    }

    bool RunDcMotorMessage::Encode(){
        if (send_buffer_ == NULL){
            Serial.print("Heap taken! ");
            Serial.println("RunDcMotor");
            send_buffer_ = (uint8_t*)calloc(128, sizeof(uint8_t));
        }
        pb_ostream_t stream = pb_ostream_from_buffer(send_buffer_, 128);
        bool status = pb_encode(&stream, RunDcMotor_fields, &data);
        messageMeta_.number_of_bytes = (uint8_t)stream.bytes_written;
        messageMeta_.valid = status;
        return status;
    }

    bool RunDcMotorMessage::Decode(const uint8_t* buffer, unsigned int number_of_bytes){
        pb_istream_t stream = pb_istream_from_buffer(buffer, number_of_bytes);
        bool status = pb_decode(&stream, RunDcMotor_fields, &data);
        messageMeta_.valid = status;
        messageMeta_.number_of_bytes = number_of_bytes;
        has_decoded_data_ = true;
        return status;
    }



ProtoIO* ProtoIO::CreateMessage(int message_type){
    switch (message_type){
        case 0:{
            return new ConfigurationMessage;
        }break;

        case 1:{
            return new BootInfoMessage;
        }break;

        case 2:{
            return new ImageMessage;
        }break;

        case 3:{
            return new TriggerMessage;
        }break;

        case 4:{
            return new TemperatureMessage;
        }break;

        case 5:{
            return new HumidityMessage;
        }break;

        case 6:{
            return new MassMessage;
        }break;

        case 7:{
            return new ElectricPowerMessage;
        }break;

        case 8:{
            return new GpsCoordinatesMessage;
        }break;

        case 9:{
            return new RunStepperMotorRawMessage;
        }break;

        case 10:{
            return new RunStepperMotorMessage;
        }break;

        case 11:{
            return new RunDcMotorMessage;
        }break;


    }
}

}
